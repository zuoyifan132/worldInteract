# Environment Configuration for WorldInteract Framework
# Pipeline Flow: Scenario Collection → Tool Domain Graph Modeling → Function Schema Programmatic Materialization

# =============================================================================
# PHASE 1: SCENARIO COLLECTION
# Raw API processing, cleaning, and standardization
# =============================================================================
scenario_collection:
  min_tool_name_length: 3
  max_tool_name_length: 50
  required_fields: ["name", "description", "parameters", "returns"]
  duplicate_threshold: 0.8  # Similarity threshold for detecting duplicates (ignored when similarity_method is "none")
  description_min_length: 10
  similarity_method: None  # Options:
                                         # - "embedding_model": Use OpenAI embeddings for semantic similarity (most accurate, requires API key)
                                         # - "sequence_matcher": Use text-based similarity (fast, no external dependencies)
                                         # - "none": Only remove exact function name duplicates (fastest)

# =============================================================================
# PHASE 2: TOOL DOMAIN GRAPH MODELING
# Domain clustering and domain analysis
# =============================================================================
domain_graph:
  save_original_domain: true # Save the original tool set without building similarity graph and community detection
  similarity_threshold: 0.5  # Cosine similarity threshold for creating edges
  min_community_size: 2      # Minimum tools per domain
  max_community_size: 20     # Maximum tools per domain
  louvain_resolution: 1.0    # Louvain algorithm resolution parameter
  enable_llm_validation: true # Whether to use LLM for domain validation
  handle_singleton: false    # Whether to handle singleton tools by assigning them to existing domains
  singleton_tool_similarity_threshold: 0.6  # Similarity threshold for singleton tools to join domains

# =============================================================================
# PHASE 3: FUNCTION SCHEMA PROGRAMMATIC MATERIALIZATION
# Database schema generation, tool implementation, and state initialization
# =============================================================================

# State generation settings
state_generation:
  min_records_per_table: 3  # Minimum number of records to generate per database table
  max_records_per_table: 5  # Maximum number of records to generate per database table

# Code agent settings (replaces tool generation + validation)
code_agent:
  test_case_num: 3  # Number of test cases to generate for each tool
  max_code_agent_rounds: 10  # Maximum number of code generation and validation rounds
  enable_sandbox: true  # Whether to enable sandboxed code execution for safety
  sandbox_timeout: 300  # Timeout in seconds for sandbox execution

# Domain-specific settings
# Suggested table names for each domain
domains:
  file_operations:
    schema_tables: ["files", "directories", "permissions", "metadata"]  # Suggested table names for file operations domain
  
  web_browsing:
    schema_tables: ["pages", "links", "cookies", "history", "bookmarks"]  # Suggested table names for web browsing domain
  
  database_management:
    schema_tables: ["databases", "tables", "indexes", "queries", "connections"]  # Suggested table names for database management domain

# =============================================================================
# PHASE 4: TASK GRAPH GENERATION AND TRAJECTORY SYNTHESIS
# Build task graphs from generated environments and synthesize agent trajectories
# =============================================================================
task_generation:
  # Task Graph Building - Build dependency graphs based on parameter similarity
  parameter_similarity_threshold: 0.4  # Cosine similarity threshold for matching input/output parameters
  
  # Subgraph Sampling - Sample subgraphs from task graph with different topologies
  min_subgraph_nodes: 5                # Minimum number of nodes in a subgraph
  max_subgraph_nodes: 20               # Maximum number of nodes in a subgraph
  num_subgraphs_per_graph: 3           # Number of subgraphs to sample per task graph
  subgraph_diversity_threshold: 0.3    # Diversity threshold for subgraph sampling (lower = more diverse)
  save_original_subgraph: true         # If true, save the original task graph as-is without sampling subgraphs
  sampling_strategies:                 # Subgraph sampling strategies to use
    random: 0.15                       # Random node selection
    bfs: 0.2                           # Breadth-first search
    dfs: 0.2                           # Depth-first search
    community: 0.15                    # Community detection
    star: 0.1                          # Star topology (hub and spokes)
    chain: 0.1                         # Linear chain
    tree: 0.1                          # Tree structure
  
  # Random Walk - Generate random walks on subgraphs
  min_walk_length: 3                   # Minimum number of nodes in a walk
  max_walk_length: 15                  # Maximum number of nodes in a walk
  num_walks_per_subgraph: 5            # Number of random walks to generate per subgraph
  walk_types: ["dag"]                  # Types of walks: "dag" (allows parallel branches), "chain" (linear path)
  dag_branch_probability: 0.3          # Probability of creating a branch in DAG walk
  dag_merge_probability: 0.25          # Probability of merging to existing node in DAG walk
  max_parallel_branches: 3             # Maximum number of parallel branches in DAG walk
  
  # Edge Validation - Validate matching_pairs in walks using LLM
  enable_edge_validation: true         # Whether to use LLM to validate edge matching_pairs (model config in model_config.yaml)
  min_matching_score: 0.5              # Minimum confidence score for a matching_pair to be valid
  
  # Task Generation with LLM - Filter walks and generate agent tasks
  enable_llm_filter: true              # Whether to use LLM to filter invalid walks
  enable_llm_task_generation: true     # Whether to use LLM to generate tasks from walks
  min_task_complexity: 3               # Minimum number of function calls in a task
  max_task_complexity: 10              # Maximum number of function calls in a task
  llm_filter_batch_size: 5             # Number of walks to process in each LLM batch

# =============================================================================
# PHASE 5: TRAJECTORY GENERATION
# Generate complete interaction trajectories from random walks using ReAct agent
# =============================================================================
trajectory_generation:
  max_react_rounds: 15                 # Maximum number of ReAct rounds per user query
  save_state_snapshots: true           # Whether to save state snapshots after each tool execution
  save_interaction_history: true       # Whether to save complete interaction history

